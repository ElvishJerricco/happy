-- Start of Happy Template (version 0.8, array based parser)

happyParse tks = happyNewToken 0 (1::Int) tks [] []

happyDoAction tk val st
	= case (happyActionArr ! (st * happy_n_terms + tk)) of
		0  		-> happyFail
		(-1) 		-> happyAccept
		n | n < 0 	-> (happyReduceArr ! -(n + 1)) tk val st
		n		-> happyShift (n - 1) tk val st

-- Ok, Here are the action functions.

happyAccept _ _ _ [ HappyAbsSyn1 ans ]  = ans
happyFail   ln tks _ = happyError ln tks

happyShift new_state tk val st ln tks sts stk =
     happyNewToken new_state ln tks (st:sts) (HappyTerminal val:stk)

happyGoto nt tk val st = happyDoAction tk val new_state
	where new_state = happyGotoArr ! (st * happy_n_nonterms + nt - 1)

-- happyReduce is specialised for the common cases.

specHappyReduce_0 nt fn tk val st ln tks sts stk
     = happyGoto nt tk val st ln tks (st:sts) (fn stk ln)
specHappyReduce_1 nt fn tk val _ ln tks sts@(st:_) stk
     = happyGoto nt tk val st ln tks sts (fn stk ln)
specHappyReduce_2 nt fn tk val _ ln tks (_:sts@(st:_)) stk
     = happyGoto nt tk val st ln tks sts (fn stk ln)
specHappyReduce_3 nt fn tk val _ ln tks (_:_:sts@(st:_)) stk
     = happyGoto nt tk val st ln tks sts (fn stk ln)

happyReduce nt k fn tk val st ln tks sts stk
              = happyGoto nt tk val st' ln tks sts' (fn stk ln)
       where sts'@(st':_) = drop (k::Int) (st:sts)

-- Internal happy errors:

notHappyAtAll :: Int -> a
notHappyAtAll i = error ("Internal Happy error in reduction ( " 
			   ++ show i ++ " )")

-- end of Happy Template.
