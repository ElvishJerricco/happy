-- $Id: HappyTemplate-arrays,v 1.11 1999/09/06 15:39:03 simonmar Exp $

happyParse = happyNewToken 0 [] []

happyDoAction i tk st
	= case (happyActionArr ! (st * happy_n_terms + i)) of
		0  		-> happyFail i tk st
		(-1) 		-> happyAccept
		n | n < 0 	-> (happyReduceArr ! (-(n + 1))) i tk st
		n		-> happyShift (n - 1) i tk st

-----------------------------------------------------------------------------
-- Accepting the parse

happyAccept sts [ HappyAbsSyn4 ans ] = happyReturn ans
happyAccept sts _                    = notHappyAtAll

-----------------------------------------------------------------------------
-- Shifting a token

happyShift new_state 1 tk st sts (HappyErrorToken i : stk) =
--     trace "shifting the error token" $
     happyDoAction i tk new_state (st:sts) stk

happyShift new_state i tk st sts stk =
     happyNewToken new_state (st:sts) (HappyTerminal tk:stk)

-- happyReduce is specialised for the common cases.

happySpecReduce_0 i fn 1 tk st sts stk
     = happyFail 1 tk st sts stk
happySpecReduce_0 nt fn j tk st sts stk
     = happyGoto nt j tk st (st:sts) (fn : stk)

happySpecReduce_1 i fn 1 tk st sts stk
     = happyFail 1 tk st sts stk
happySpecReduce_1 nt fn j tk _ sts@(st:_) (v1:stk')
     = happyGoto nt j tk st sts (fn v1 : stk')

happySpecReduce_2 i fn 1 tk st sts stk
     = happyFail 1 tk st sts stk
happySpecReduce_2 nt fn j tk _ (_:sts@(st:_)) (v1:v2:stk')
     = happyGoto nt j tk st sts (fn v1 v2 : stk')

happySpecReduce_3 i fn 1 tk st sts stk
     = happyFail 1 tk st sts stk
happySpecReduce_3 nt fn j tk _ (_:_:sts@(st:_)) (v1:v2:v3:stk')
     = happyGoto nt j tk st sts (fn v1 v2 v3 : stk')

happyRedcue k i fn 1 tk st sts stk
     = happyFail 1 tk st sts stk
happyReduce k nt fn j tk st sts stk = happyGoto nt j tk st' sts' (fn stk)
       where sts'@(st':_) = drop (k::Int) (st:sts)

happyMonadReduce k nt c fn 1 tk st sts stk
     = happyFail 1 tk st sts stk
happyMonadReduce k nt c fn j tk st sts stk =
        happyThen (fn stk) (\r -> happyGoto nt j tk st' sts' (c r : stk'))
       where sts'@(st':_) = drop (k::Int) (st:sts)
             stk' = drop (k::Int) stk

-----------------------------------------------------------------------------
-- Moving to a new state after a reduction

-- subtract 4 from nt, because nonterminals start at 4 (see Grammar.hs)
happyGoto nt j tk st = happyDoAction j tk new_state
	where new_state = happyGotoArr ! (st * happy_n_nonterms + nt - 4)

-----------------------------------------------------------------------------
-- Error recovery (1 is the error token)

-- parse error if we are in recovery and we fail again
happyFail  1 tk st' [] stk =
--	trace "failing" $ 
    	happyError

-- discard a state
happyFail  1 tk st' (st:sts) (saved_tok : _ : stk) =
--	trace ("discarding state, depth " ++ show (length stk))  $
	happyDoAction 1 tk st sts (saved_tok:stk)

-- Enter error recovery: generate an error token,
--                       save the old token and carry on.
happyFail  i tk st sts stk =
--      trace "entering error recovery" $
        happyDoAction 1 tk st sts (HappyErrorToken i : stk)

-- Internal happy errors:

notHappyAtAll = error "Internal Happy error\n"

-- end of Happy Template.
