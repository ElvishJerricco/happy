-- parser produced by Happy Version 1.1-simonm


data HappyAbsSyn 
	= HappyTerminal Token
	| HappyErrorToken Int
	| HappyAbsSyn1(Exp)
	| HappyAbsSyn2(Exp1)
	| HappyAbsSyn3(Term)
	| HappyAbsSyn4(Factor)

happyActionArr :: Array Int Int
happyActionArr = listArray (-1,312) ([0,6,0,7,8,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-3,0,0,0,14,15,0,0,0,-3,-3,0,0,-6,0,0,0,-6,-6,12,13,0,-6,-6,0,0,-9,0,0,0,-9,-9,-9,-9,0,-9,-9,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,-10,0,0,0,-10,-10,-10,-10,0,-10,-10,0,0,-11,0,0,0,-11,-11,-11,-11,0,-11,-11,0,6,0,7,8,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,20,0,0,0,0,0,0,0,0,0,0,7,8,0,0,0,0,0,9,0,0,0,0,0,7,8,0,0,0,0,0,9,0,0,0,0,0,7,8,0,0,0,0,0,9,0,0,0,0,0,7,8,0,0,0,0,0,9,0,0,0,0,-5,0,0,0,-5,-5,12,13,0,-5,-5,0,0,-4,0,0,0,-4,-4,12,13,0,-4,-4,0,0,-8,0,0,0,-8,-8,-8,-8,0,-8,-8,0,0,-7,0,0,0,-7,-7,-7,-7,0,-7,-7,0,6,0,7,8,0,0,0,0,0,9,0,0,0,0,-12,0,0,0,-12,-12,-12,-12,0,-12,-12,0,0,23,0,0,0,0,0,0,0,0,0,0,0,6,0,7,8,0,0,0,0,0,9,0,0,0,0,-2,0,0,0,0,0,0,0,0,-2,-2
	])

happyGotoArr :: Array Int Int
happyGotoArr = listArray (0, 96) ([1,2,3,4] ++ take 28 (repeat 0) ++ [9,2,3,4,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,17,0,0,16,4,0,0,15,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,2,3,4,0,0,0,0,0,0,0,0,23,2,3,4,0,0,0,0
	])

happyReduceArr = array (1, 11) [
	1 := happyReduce_1,
	2 := happyReduce_2,
	3 := happyReduce_3,
	4 := happyReduce_4,
	5 := happyReduce_5,
	6 := happyReduce_6,
	7 := happyReduce_7,
	8 := happyReduce_8,
	9 := happyReduce_9,
	10 := happyReduce_10,
	11 := happyReduce_11
	]

happy_n_terms = 13 :: Int
happy_n_nonterms = 4 :: Int

happyReduce_1 = happyReduce 6 1 reduction where {
  reduction
	((HappyAbsSyn1  happy_var_6) :
	_ :
	(HappyAbsSyn1  happy_var_4) :
	_ :
	(HappyTerminal (TokenVar happy_var_2)) :
	_ :
	happyRest)
	 = HappyAbsSyn1
		 (Let happy_var_2 happy_var_4 happy_var_6) : happyRest;
  reduction _ = notHappyAtAll }

happyReduce_2 = happySpecReduce_1 1 reduction where {
  reduction
	(HappyAbsSyn2  happy_var_1)
	 =  HappyAbsSyn1
		 (Exp1 happy_var_1);
  reduction _  = notHappyAtAll }

happyReduce_3 = happySpecReduce_3 2 reduction where {
  reduction
	(HappyAbsSyn3  happy_var_3)
	_
	(HappyAbsSyn2  happy_var_1)
	 =  HappyAbsSyn2
		 (Plus happy_var_1 happy_var_3);
  reduction _ _ _  = notHappyAtAll }

happyReduce_4 = happySpecReduce_3 2 reduction where {
  reduction
	(HappyAbsSyn3  happy_var_3)
	_
	(HappyAbsSyn2  happy_var_1)
	 =  HappyAbsSyn2
		 (Minus happy_var_1 happy_var_3);
  reduction _ _ _  = notHappyAtAll }

happyReduce_5 = happySpecReduce_1 2 reduction where {
  reduction
	(HappyAbsSyn3  happy_var_1)
	 =  HappyAbsSyn2
		 (Term happy_var_1);
  reduction _  = notHappyAtAll }

happyReduce_6 = happySpecReduce_3 3 reduction where {
  reduction
	(HappyAbsSyn4  happy_var_3)
	_
	(HappyAbsSyn3  happy_var_1)
	 =  HappyAbsSyn3
		 (Times happy_var_1 happy_var_3);
  reduction _ _ _  = notHappyAtAll }

happyReduce_7 = happySpecReduce_3 3 reduction where {
  reduction
	(HappyAbsSyn4  happy_var_3)
	_
	(HappyAbsSyn3  happy_var_1)
	 =  HappyAbsSyn3
		 (Div happy_var_1 happy_var_3);
  reduction _ _ _  = notHappyAtAll }

happyReduce_8 = happySpecReduce_1 3 reduction where {
  reduction
	(HappyAbsSyn4  happy_var_1)
	 =  HappyAbsSyn3
		 (Factor happy_var_1);
  reduction _  = notHappyAtAll }

happyReduce_9 = happySpecReduce_1 4 reduction where {
  reduction
	(HappyTerminal (TokenInt happy_var_1))
	 =  HappyAbsSyn4
		 (Int happy_var_1);
  reduction _  = notHappyAtAll }

happyReduce_10 = happySpecReduce_1 4 reduction where {
  reduction
	(HappyTerminal (TokenVar happy_var_1))
	 =  HappyAbsSyn4
		 (Var happy_var_1);
  reduction _  = notHappyAtAll }

happyReduce_11 = happySpecReduce_3 4 reduction where {
  reduction
	_
	(HappyAbsSyn1  happy_var_2)
	_
	 =  HappyAbsSyn4
		 (Brack happy_var_2);
  reduction _ _ _  = notHappyAtAll }

happyNewToken action sts stk [] =
	happyDoAction 11 (error "reading EOF!") action sts stk []

happyNewToken action sts stk (tk:tks) =
	let cont i = happyDoAction i tk action sts stk tks in
	case tk of {
	TokenLet -> cont 0;
	TokenIn -> cont 1;
	TokenInt _ -> cont 2;
	TokenVar _ -> cont 3;
	TokenEq -> cont 4;
	TokenPlus -> cont 5;
	TokenMinus -> cont 6;
	TokenTimes -> cont 7;
	TokenDiv -> cont 8;
	TokenOB -> cont 9;
	TokenCB -> cont 10;
	}

happyThen = \m k -> k m
happyReturn = \a tks -> a
calc = happyParse







happyError tks = error "Parse error"



data Exp  = Let String Exp Exp | Exp1 Exp1 
data Exp1 = Plus Exp1 Term | Minus Exp1 Term | Term Term 
data Term = Times Term Factor | Div Term Factor | Factor Factor 
data Factor = Int Int | Var String | Brack Exp 



data Token
	= TokenLet
	| TokenIn
	| TokenInt Int
	| TokenVar String
	| TokenEq
	| TokenPlus
	| TokenMinus
	| TokenTimes
	| TokenDiv
	| TokenOB
	| TokenCB



lexer :: String -> [Token]
lexer [] = []
lexer (c:cs) 
	| isSpace c = lexer cs
	| isAlpha c = lexVar (c:cs)
	| isDigit c = lexNum (c:cs)
lexer ('=':cs) = TokenEq : lexer cs
lexer ('+':cs) = TokenPlus : lexer cs
lexer ('-':cs) = TokenMinus : lexer cs
lexer ('*':cs) = TokenTimes : lexer cs
lexer ('/':cs) = TokenDiv : lexer cs
lexer ('(':cs) = TokenOB : lexer cs
lexer (')':cs) = TokenCB : lexer cs

lexNum cs = TokenInt (read num) : lexer rest
	where (num,rest) = span isDigit cs

lexVar cs =
   case span isAlpha cs of
	("let",rest) -> TokenLet : lexer rest
	("in",rest)  -> TokenIn : lexer rest
	(var,rest)   -> TokenVar var : lexer rest




runCalc :: String -> Exp
runCalc = calc . lexer



main = case runCalc "1 + 2 + 3" of {
	(Exp1 (Plus (Plus (Term (Factor (Int 1))) (Factor (Int 2))) (Factor (Int 3))))  ->
	case runCalc "1 * 2 + 3" of {
	(Exp1 (Plus (Term (Times (Factor (Int 1)) (Int 2))) (Factor (Int 3)))) ->
	case runCalc "1 + 2 * 3" of {
	(Exp1 (Plus (Term (Factor (Int 1))) (Times (Factor (Int 2)) (Int 3)))) ->
	case runCalc "let x = 2 in x * (x - 2)" of {
	(Let "x" (Exp1 (Term (Factor (Int 2)))) (Exp1 (Term (Times (Factor (Var "x")) (Brack (Exp1 (Minus (Term (Factor (Var "x"))) (Factor (Int 2))))))))) -> appendChan stdout "Test works\n" abort done; 
	_ -> quit } ; _ -> quit } ; _ -> quit } ; _ -> quit }
quit = appendChan stdout "Test failed\n" abort done

-- $Id: Test.hs-CMP-a,v 1.1 1997/03/28 14:57:58 simonm Exp $

happyParse = happyNewToken 0 [] []

happyDoAction i tk st
	= case (happyActionArr ! (st * happy_n_terms + i)) of
		0  		-> happyFail i tk st
		(-1) 		-> happyAccept
		n | n < 0 	-> (happyReduceArr ! -(n + 1)) i tk st
		n		-> happyShift (n - 1) i tk st

-----------------------------------------------------------------------------
-- Accepting the parse

happyAccept sts [ HappyAbsSyn1 ans ] = happyReturn ans
happyAccept sts _                    = notHappyAtAll

-----------------------------------------------------------------------------
-- Shifting a token

happyShift new_state (-1) tk st sts (HappyErrorToken i : stk) =
--     _trace "shifting the error token" $
     happyDoAction i tk new_state (st:sts) stk

happyShift new_state i tk st sts stk =
     happyNewToken new_state (st:sts) (HappyTerminal tk:stk)

-- happyReduce is specialised for the common cases.

happySpecReduce_0 i fn (-1) tk _ sts stk
     = case sts of
	st:sts -> happyDoAction (-1) tk st sts stk
	_ -> happyError
happySpecReduce_0 nt fn j tk st sts stk
     = happyGoto nt j tk st (st:sts) (fn : stk)

happySpecReduce_1 i fn (-1) tk _ (st:sts) stk
     = happyDoAction (-1) tk st sts stk
happySpecReduce_1 nt fn j tk _ sts@(st:_) (v1:stk')
     = happyGoto nt j tk st sts (fn v1 : stk')

happySpecReduce_2 i fn (-1) tk _ (st:sts) stk
     = happyDoAction (-1) tk st sts stk
happySpecReduce_2 nt fn j tk _ (_:sts@(st:_)) (v1:v2:stk')
     = happyGoto nt j tk st sts (fn v1 v2 : stk')

happySpecReduce_3 i fn (-1) tk _ (st:sts) stk
     = happyDoAction (-1) tk st sts stk
happySpecReduce_3 nt fn j tk _ (_:_:sts@(st:_)) (v1:v2:v3:stk')
     = happyGoto nt j tk st sts (fn v1 v2 v3 : stk')

happyReduce k i fn (-1) tk _ (st:sts) stk
     = happyDoAction (-1) tk st sts stk
happyReduce k nt fn j tk st sts stk = happyGoto nt j tk st' sts' (fn stk)
       where sts'@(st':_) = drop (k::Int) (st:sts)

happyMonadReduce k i c fn (-1) tk _ (st:sts) stk
     = happyDoAction (-1) tk st sts stk
happyMonadReduce k nt c fn j tk st sts stk =
        happyThen (fn stk) (\r -> happyGoto nt j tk st' sts' (c r : stk'))
       where sts'@(st':_) = drop (k::Int) (st:sts)
             stk' = drop (k::Int) stk

-----------------------------------------------------------------------------
-- Moving to a new state after a reduction

happyGoto nt j tk st = happyDoAction j tk new_state
	where new_state = happyGotoArr ! (st * happy_n_nonterms + nt - 1)

-----------------------------------------------------------------------------
-- Error recovery (-1 is the error token)

-- fail if we are in recovery and no more states to discard
happyFail  (-1) tk st' [] stk = happyError

-- discard a state
happyFail  (-1) tk st' (st:sts) stk =
--      _trace "discarding state" $
        happyDoAction (-1) tk st sts stk

-- Enter error recovery: generate an error token,
--                       save the old token and carry on.
happyFail  i tk st sts stk =
--      _trace "entering error recovery" $
        happyDoAction (-1) tk st sts (HappyErrorToken i : stk)

-- Internal happy errors:

notHappyAtAll = error "Internal Happy error\n"

-- end of Happy Template.
